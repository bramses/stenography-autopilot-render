[{"code":"function (req, res, next) {\n  res.render('test');\n}","start":1799,"end":1850,"charLength":51,"type":"function","startLine":59,"endLine":61,"stenographyResponse":{"code":"function (req, res, next) {\n  res.render('test');\n}","pm":"This code is rendering a template.","metadata":{"language":"JavaScript"}}},{"code":"function (req, res, next) {\n  res.render('index', { title: 'Express', foods: ['Pizza', 'Pasta', 'Salad'] });\n}","start":1661,"end":1771,"charLength":110,"type":"function","startLine":55,"endLine":57,"stenographyResponse":{"code":"function (req, res, next) {\n  res.render('index', { title: 'Express', foods: ['Pizza', 'Pasta', 'Salad'] });\n}","pm":"This code is rendering a template.","metadata":{"language":"Express is a web application framework for Node.js"}}},{"code":"async (req, res) => {\n  const twiml = new MessagingResponse();\n  await workflow(`${req.body.Body}`)\n  // twiml.message('The Robots are coming! Head for the hills!');\n\n  res.writeHead(200, {'Content-Type': 'text/xml'});\n  res.end('yeet');\n}","start":1874,"end":2113,"charLength":239,"type":"function","startLine":63,"endLine":70,"stenographyResponse":{"code":"async (req, res) => {\n  const twiml = new MessagingResponse();\n  await workflow(`${req.body.Body}`)\n  // twiml.message('The Robots are coming! Head for the hills!');\n\n  res.writeHead(200, {'Content-Type': 'text/xml'});\n  res.end('yeet');\n}","pm":"This code is taking the text message from a user and sending it to our workflow function.\nThe workflow function will then take that input, run some code on it, and return a response.\nThis response will be sent back to Twilio so that we can send it back to the user who texted us.","metadata":{"language":"Node.js"}}},{"code":"async function (msg) {\n  let testPug = await fs.readFile('./views/test.pug', 'utf8');\n  let testCss = await fs.readFile('./public/stylesheets/test.css', 'utf8');\n\n  let isCSS = false;\n  if (msg.includes('ðŸŽ¨')) {\n    isCSS = true;\n    msg = msg.replace('ðŸŽ¨', '');\n  }\n  else if (msg.includes('ðŸ¶')) {\n    isCSS = false;\n    msg = msg.replace('ðŸ¶', '');\n  }\n \n  if (!isCSS) {\n    const tr = await gptCall(testPug, msg, 'pug');\n    testPug += \"\\n\" + tr.code.split('\\n').map(line => `    ${line}`).join('\\n');\n    await fs.writeFile('./views/test.pug', testPug, 'utf8');\n  } else {\n    const tr = await gptCall(testCss, msg, 'css');\n    testCss += \"\\n\" + tr.code.trim();\n    await fs.writeFile('./public/stylesheets/test.css', testCss, 'utf8');\n  }\n}","start":2134,"end":2880,"charLength":746,"type":"function","startLine":72,"endLine":95,"stenographyResponse":{"code":"async function (msg) {\n  let testPug = await fs.readFile('./views/test.pug', 'utf8');\n  let testCss = await fs.readFile('./public/stylesheets/test.css', 'utf8');\n\n  let isCSS = false;\n  if (msg.includes('ðŸŽ¨')) {\n    isCSS = true;\n    msg = msg.replace('ðŸŽ¨', '');\n  }\n  else if (msg.includes('ðŸ¶')) {\n    isCSS = false;\n    msg = msg.replace('ðŸ¶', '');\n  }\n \n  if (!isCSS) {\n    const tr = await gptCall(testPug, msg, 'pug');\n    testPug += \"\\n\" + tr.code.split('\\n').map(line => `    ${line}`).join('\\n');\n    await fs.writeFile('./views/test.pug', testPug, 'utf8');\n  } else {\n    const tr = await gptCall(testCss, msg, 'css');\n    testCss += \"\\n\" + tr.code.trim();\n    await fs.writeFile('./public/stylesheets/test.css', testCss, 'utf8');\n  }\n}","pm":"This code is a bot that can convert pug to css and vice versa.\nIt uses the [Google Cloud Platform's translate API](https://cloud.google.com/translate/) to do so, which I have set up for free on my Google account.\nThe code will read in the file specified by `./views/test.[pug|css]` and send it through the API with the message given as an argument (the command). It then saves this new translation into a new file of the same name but with `_tr` appended at the end, e.g., if you give it \"ðŸŽ¨\" as an argument, it will save your translated pug into `./views/test_tr.pug`.","metadata":{"language":"JavaScript"}}},{"code":"async function (req, res, next) {\n  let testPug = await fs.readFile('./views/test.pug', 'utf8');\n  let testCss = await fs.readFile('./public/stylesheets/test.css', 'utf8');\n\n  let body = req.body;\n\n  let isCSS = false;\n  if (body.command.includes('ðŸŽ¨')) {\n    isCSS = true;\n    body.command = body.command.replace('ðŸŽ¨', '');\n  }\n  else if (body.command.includes('ðŸ¶')) {\n    isCSS = false;\n    body.command = body.command.replace('ðŸ¶', '');\n  }\n \n  if (!isCSS) {\n    const tr = await gptCall(testPug, body.command, 'pug');\n    testPug += \"\\n\" + tr.code.split('\\n').map(line => `    ${line}`).join('\\n');\n    await fs.writeFile('./views/test.pug', testPug, 'utf8');\n    res.status(200).send(testPug);\n  } else {\n    const tr = await gptCall(testCss, body.command, 'css');\n    testCss += \"\\n\" + tr.code.trim();\n    await fs.writeFile('./public/stylesheets/test.css', testCss, 'utf8');\n    res.status(200).send(testCss);\n  }\n}","start":2903,"end":3826,"charLength":923,"type":"function","startLine":97,"endLine":124,"stenographyResponse":{"code":"async function (req, res, next) {\n  let testPug = await fs.readFile('./views/test.pug', 'utf8');\n  let testCss = await fs.readFile('./public/stylesheets/test.css', 'utf8');\n\n  let body = req.body;\n\n  let isCSS = false;\n  if (body.command.includes('ðŸŽ¨')) {\n    isCSS = true;\n    body.command = body.command.replace('ðŸŽ¨', '');\n  }\n  else if (body.command.includes('ðŸ¶')) {\n    isCSS = false;\n    body.command = body.command.replace('ðŸ¶', '');\n  }\n \n  if (!isCSS) {\n    const tr = await gptCall(testPug, body.command, 'pug');\n    testPug += \"\\n\" + tr.code.split('\\n').map(line => `    ${line}`).join('\\n');\n    await fs.writeFile('./views/test.pug', testPug, 'utf8');\n    res.status(200).send(testPug);\n  } else {\n    const tr = await gptCall(testCss, body.command, 'css');\n    testCss += \"\\n\" + tr.code.trim();\n    await fs.writeFile('./public/stylesheets/test.css', testCss, 'utf8');\n    res.status(200).send(testCss);\n  }\n}","pm":"This code is a simple server that takes in POST requests from the client.\nThe request body contains the command to be run and whether it's CSS or Pug.\nIt then runs the code through Google's [GPT3](https://github.com/openai/gpt3) API, which returns a JSON object with two keys: `code` and `success`. The code key holds what we want  our generated text! We can then write this to either a pug file or css file depending on what was requested by the user.","metadata":{"language":"JavaScript"}}},{"code":"async (fileContent, command, language) => {\n  try {\n    const engine = 'davinci-codex'\n\n    let prompt = ''\n    if (language === 'css') {\n      prompt = `Language: css\\n\\n${fileContent}\\n\\n/* ${command} */`;\n    } else {\n      prompt = `Language: pug\\n\\n${fileContent}\\n\\n/* ${command} */`;\n    }\n\n    const topP = 1\n    const presencePenalty = 0.5\n    const frequencyPenalty = 0.5\n    const temperature = 0.0\n    const maxTokens = 150\n    const bestOf = 1\n    const n = 1\n    const stream = false\n    const stop = [\"/*\"]\n\n    /*\n    This code is waiting for the OpenAI API to return a prompt completion.\n    - generated by stenography ðŸ¤–\n    */\n    const response = await openai.complete({ engine, prompt, maxTokens, temperature, topP, presencePenalty, frequencyPenalty, bestOf, n, stream, stop });\n\n    console.log(response.data)\n\n    // const texts = response.data.choices.map(choice => choice.text);\n    // const shortestText = response.data.choices.sort((a, b) => a.text.length - b.text.length)[0].text;\n\n    return {\n      code: response.data.choices[0].text,\n    }\n  } catch (err) {\n    throw err;\n  }\n}","start":512,"end":1622,"charLength":1110,"type":"function","startLine":14,"endLine":52,"stenographyResponse":{"code":"async (fileContent, command, language) => {\n  try {\n    const engine = 'davinci-codex'\n\n    let prompt = ''\n    if (language === 'css') {\n      prompt = `Language: css\\n\\n${fileContent}\\n\\n/* ${command} */`;\n    } else {\n      prompt = `Language: pug\\n\\n${fileContent}\\n\\n/* ${command} */`;\n    }\n\n    const topP = 1\n    const presencePenalty = 0.5\n    const frequencyPenalty = 0.5\n    const temperature = 0.0\n    const maxTokens = 150\n    const bestOf = 1\n    const n = 1\n    const stream = false\n    const stop = [\"/*\"]\n\n    /*\n    This code is waiting for the OpenAI API to return a prompt completion.\n    - generated by stenography ðŸ¤–\n    */\n    const response = await openai.complete({ engine, prompt, maxTokens, temperature, topP, presencePenalty, frequencyPenalty, bestOf, n, stream, stop });\n\n    console.log(response.data)\n\n    // const texts = response.data.choices.map(choice => choice.text);\n    // const shortestText = response.data.choices.sort((a, b) => a.text.length - b.text.length)[0].text;\n\n    return {\n      code: response.data.choices[0].text,\n    }\n  } catch (err) {\n    throw err;\n  }\n}","pm":"This code is waiting for the OpenAI API to return a prompt completion.\n generated by stenography ðŸ¤–\n","metadata":{"language":"JavaScript"}}}]